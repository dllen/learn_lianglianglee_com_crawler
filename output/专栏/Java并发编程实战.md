# Java并发编程实战 

Source: https://learn.lianglianglee.com/专栏/Java并发编程实战

因收到Google相关通知，网站将会择期关闭。[相关通知内容](https://lumendatabase.org/notices/44265620)

---

# Java并发编程实战

* [00 学习攻略 如何才能学好并发编程？.md](/专栏/Java并发编程实战/00 学习攻略 如何才能学好并发编程？.md)
* [00 开篇词 你为什么需要学习并发编程？.md](/专栏/Java并发编程实战/00 开篇词 你为什么需要学习并发编程？.md)
* [01 可见性、原子性和有序性问题：并发编程Bug的源头.md](/专栏/Java并发编程实战/01 可见性、原子性和有序性问题：并发编程Bug的源头.md)
* [02 Java内存模型：看Java如何解决可见性和有序性问题.md](/专栏/Java并发编程实战/02 Java内存模型：看Java如何解决可见性和有序性问题.md)
* [03 互斥锁（上）：解决原子性问题.md](/专栏/Java并发编程实战/03 互斥锁（上）：解决原子性问题.md)
* [04 互斥锁（下）：如何用一把锁保护多个资源？.md](/专栏/Java并发编程实战/04 互斥锁（下）：如何用一把锁保护多个资源？.md)
* [05 一不小心就死锁了，怎么办？.md](/专栏/Java并发编程实战/05 一不小心就死锁了，怎么办？.md)
* [06 用“等待-通知”机制优化循环等待.md](/专栏/Java并发编程实战/06 用“等待-通知”机制优化循环等待.md)
* [07 安全性、活跃性以及性能问题.md](/专栏/Java并发编程实战/07 安全性、活跃性以及性能问题.md)
* [08 管程：并发编程的万能钥匙.md](/专栏/Java并发编程实战/08 管程：并发编程的万能钥匙.md)
* [09 Java线程（上）：Java线程的生命周期.md](/专栏/Java并发编程实战/09 Java线程（上）：Java线程的生命周期.md)
* [10 Java线程（中）：创建多少线程才是合适的？.md](/专栏/Java并发编程实战/10 Java线程（中）：创建多少线程才是合适的？.md)
* [11 Java线程（下）：为什么局部变量是线程安全的？.md](/专栏/Java并发编程实战/11 Java线程（下）：为什么局部变量是线程安全的？.md)
* [12 如何用面向对象思想写好并发程序？.md](/专栏/Java并发编程实战/12 如何用面向对象思想写好并发程序？.md)
* [13 理论基础模块热点问题答疑.md](/专栏/Java并发编程实战/13 理论基础模块热点问题答疑.md)
* [14 Lock和Condition（上）：隐藏在并发包中的管程.md](/专栏/Java并发编程实战/14 Lock和Condition（上）：隐藏在并发包中的管程.md)
* [15 Lock和Condition（下）：Dubbo如何用管程实现异步转同步？.md](/专栏/Java并发编程实战/15 Lock和Condition（下）：Dubbo如何用管程实现异步转同步？.md)
* [16 Semaphore：如何快速实现一个限流器？.md](/专栏/Java并发编程实战/16 Semaphore：如何快速实现一个限流器？.md)
* [17 ReadWriteLock：如何快速实现一个完备的缓存？.md](/专栏/Java并发编程实战/17 ReadWriteLock：如何快速实现一个完备的缓存？.md)
* [18 StampedLock：有没有比读写锁更快的锁？.md](/专栏/Java并发编程实战/18 StampedLock：有没有比读写锁更快的锁？.md)
* [19 CountDownLatch和CyclicBarrier：如何让多线程步调一致？.md](/专栏/Java并发编程实战/19 CountDownLatch和CyclicBarrier：如何让多线程步调一致？.md)
* [20 并发容器：都有哪些“坑”需要我们填？.md](/专栏/Java并发编程实战/20 并发容器：都有哪些“坑”需要我们填？.md)
* [21 原子类：无锁工具类的典范.md](/专栏/Java并发编程实战/21 原子类：无锁工具类的典范.md)
* [22 Executor与线程池：如何创建正确的线程池？.md](/专栏/Java并发编程实战/22 Executor与线程池：如何创建正确的线程池？.md)
* [23 Future：如何用多线程实现最优的“烧水泡茶”程序？.md](/专栏/Java并发编程实战/23 Future：如何用多线程实现最优的“烧水泡茶”程序？.md)
* [24 CompletableFuture：异步编程没那么难.md](/专栏/Java并发编程实战/24 CompletableFuture：异步编程没那么难.md)
* [25 CompletionService：如何批量执行异步任务？.md](/专栏/Java并发编程实战/25 CompletionService：如何批量执行异步任务？.md)
* [26 Fork\_Join：单机版的MapReduce.md](/专栏/Java并发编程实战/26 Fork_Join：单机版的MapReduce.md)
* [27 并发工具类模块热点问题答疑.md](/专栏/Java并发编程实战/27 并发工具类模块热点问题答疑.md)
* [28 Immutability模式：如何利用不变性解决并发问题？.md](/专栏/Java并发编程实战/28 Immutability模式：如何利用不变性解决并发问题？.md)
* [29 Copy-on-Write模式：不是延时策略的COW.md](/专栏/Java并发编程实战/29 Copy-on-Write模式：不是延时策略的COW.md)
* [3 个用户来信 打开一个新的并发世界.md](/专栏/Java并发编程实战/3 个用户来信 打开一个新的并发世界.md)
* [30 线程本地存储模式：没有共享，就没有伤害.md](/专栏/Java并发编程实战/30 线程本地存储模式：没有共享，就没有伤害.md)
* [31 Guarded Suspension模式：等待唤醒机制的规范实现.md](/专栏/Java并发编程实战/31 Guarded Suspension模式：等待唤醒机制的规范实现.md)
* [32 Balking模式：再谈线程安全的单例模式.md](/专栏/Java并发编程实战/32 Balking模式：再谈线程安全的单例模式.md)
* [33 Thread-Per-Message模式：最简单实用的分工方法.md](/专栏/Java并发编程实战/33 Thread-Per-Message模式：最简单实用的分工方法.md)
* [34 Worker Thread模式：如何避免重复创建线程？.md](/专栏/Java并发编程实战/34 Worker Thread模式：如何避免重复创建线程？.md)
* [35 两阶段终止模式：如何优雅地终止线程？.md](/专栏/Java并发编程实战/35 两阶段终止模式：如何优雅地终止线程？.md)
* [36 生产者-消费者模式：用流水线思想提高效率.md](/专栏/Java并发编程实战/36 生产者-消费者模式：用流水线思想提高效率.md)
* [37 设计模式模块热点问题答疑.md](/专栏/Java并发编程实战/37 设计模式模块热点问题答疑.md)
* [38 案例分析（一）：高性能限流器Guava RateLimiter.md](/专栏/Java并发编程实战/38 案例分析（一）：高性能限流器Guava RateLimiter.md)
* [39 案例分析（二）：高性能网络应用框架Netty.md](/专栏/Java并发编程实战/39 案例分析（二）：高性能网络应用框架Netty.md)
* [40 案例分析（三）：高性能队列Disruptor.md](/专栏/Java并发编程实战/40 案例分析（三）：高性能队列Disruptor.md)
* [41 案例分析（四）：高性能数据库连接池HiKariCP.md](/专栏/Java并发编程实战/41 案例分析（四）：高性能数据库连接池HiKariCP.md)
* [42 Actor模型：面向对象原生的并发模型.md](/专栏/Java并发编程实战/42 Actor模型：面向对象原生的并发模型.md)
* [43 软件事务内存：借鉴数据库的并发经验.md](/专栏/Java并发编程实战/43 软件事务内存：借鉴数据库的并发经验.md)
* [44 协程：更轻量级的线程.md](/专栏/Java并发编程实战/44 协程：更轻量级的线程.md)
* [45 CSP模型：Golang的主力队员.md](/专栏/Java并发编程实战/45 CSP模型：Golang的主力队员.md)
* [用户来信 真好，面试考到这些并发编程，我都答对了！.md](/专栏/Java并发编程实战/用户来信 真好，面试考到这些并发编程，我都答对了！.md)
* [结束语 十年之后，初心依旧.md](/专栏/Java并发编程实战/结束语 十年之后，初心依旧.md)